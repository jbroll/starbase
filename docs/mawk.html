<HTML>
<BODY>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
     mawk - pattern scanning and text processing language


</PRE>
<H2>SYNOPSIS</H2><PRE>
     <STRONG>mawk</STRONG> [-<STRONG>W</STRONG> <EM>option</EM>] [-<STRONG>F</STRONG> <EM>value</EM>]  [-<STRONG>v</STRONG>  <EM>var</EM>=<EM>value</EM>]  [--]  'program
     text' [file ...]
     <STRONG>mawk</STRONG> [-<STRONG>W</STRONG> <EM>option</EM>] [-<STRONG>F</STRONG> <EM>value</EM>] [-<STRONG>v</STRONG> <EM>var</EM>=<EM>value</EM>] [-<STRONG>f</STRONG> <EM>program</EM>-<EM>file</EM>]
     [--] [file ...]


</PRE>
<H2>DESCRIPTION</H2><PRE>
     <STRONG>mawk</STRONG> is an interpreter for  the  AWK  Programming  Language.
     The  AWK  language is useful for manipulation of data files,
     text retrieval  and  processing,  and  for  prototyping  and
     experimenting with algorithms.  <STRONG>mawk</STRONG> is a <EM>new</EM> <EM>awk</EM> meaning it
     implements the AWK language as defined in Aho, Kernighan and
     Weinberger,  <EM>The</EM>  <EM>AWK</EM>  <EM>Programming</EM>  <EM>Language</EM>, Addison-Wesley
     Publishing, 1988.  (Hereafter referred to as the AWK  book.)
     <STRONG>mawk</STRONG> conforms to the Posix 1003.2 (draft 11.3) definition of
     the AWK language which contains a few features not described
     in the AWK book,  and <STRONG>mawk</STRONG> provides a small number of exten-
     sions.

     An AWK program is a sequence of <EM>pattern</EM> {<EM>action</EM>}  pairs  and
     function  definitions.   Short  programs  are entered on the
     command  line  usually  enclosed  in  '  '  to  avoid  shell
     interpretation.   Longer programs can be read in from a file
     with the -f option.  Data  input is read from  the  list  of
     files  on  the  command line or from standard input when the
     list is empty.  The input is broken into records  as  deter-
     mined by the record separator variable, <STRONG>RS</STRONG>.  Initially, <STRONG>RS</STRONG> =
     "\n" and records are synonymous with lines.  Each record  is
     compared against each <EM>pattern</EM> and if it matches, the program
     text for {<EM>action</EM>} is executed.


</PRE>
<H2>OPTIONS</H2><PRE>
     -<STRONG>F</STRONG> <EM>value</EM>       sets the field separator, <STRONG>FS</STRONG>, to <EM>value</EM>.

     -<STRONG>f</STRONG> <EM>file</EM>        Program text is read  from  <EM>file</EM>  instead  of
                    from  the  command line.  Multiple -<STRONG>f</STRONG> options
                    are allowed.

     -<STRONG>v</STRONG> <EM>var</EM>=<EM>value</EM>   assigns <EM>value</EM> to program variable <EM>var</EM>.

     --             indicates the unambiguous end of options.

     The above options will be available with any Posix  compati-
     ble  implementation  of  AWK,  and  implementation  specific
     options are prefaced with -<STRONG>W</STRONG>.  <STRONG>mawk</STRONG> provides six:

     -<STRONG>W</STRONG> version     <STRONG>mawk</STRONG> writes  its  version  and  copyright  to
                    stdout  and  compiled  limits  to  stderr and
                    exits 0.

     -<STRONG>W</STRONG> dump        writes  an  assembler  like  listing  of  the
                    internal  representation  of  the  program to
                    stdout and exits 0  (on  successful  compila-
                    tion).

     -<STRONG>W</STRONG> interactive sets unbuffered writes  to  stdout  and  line
                    buffered  reads  from  stdin.   Records  from
                    stdin are lines regardless of  the  value  of
                    <STRONG>RS</STRONG>.

     -<STRONG>W</STRONG> exec <EM>file</EM>   Program text is read from <EM>file</EM>  and  this  is
                    the  last option. Useful on systems that sup-
                    port the <STRONG>#!</STRONG>  "magic  number"  convention  for
                    executable scripts.

     -<STRONG>W</STRONG> sprintf=<EM>num</EM> adjusts the size of <STRONG>mawk's</STRONG>  internal  sprintf
                    buffer  to  <EM>num</EM> bytes.  More than rare use of
                    this option indicates <STRONG>mawk</STRONG> should  be  recom-
                    piled.

     -<STRONG>W</STRONG> posix_space forces <STRONG>mawk</STRONG> not to consider '\n' to be space.

     The short forms -<STRONG>W</STRONG>[vdiesp] are recoginized and on some  sys-
     tems  <STRONG>-W</STRONG>e  is mandatory to avoid command line length limita-
     tions.


</PRE>
<H2>THE AWK LANGUAGE</H2><PRE>
  <STRONG>1.</STRONG> <STRONG>Program</STRONG> <STRONG>structure</STRONG>
     An AWK program is a sequence of <EM>pattern</EM> {<EM>action</EM>}  pairs  and
     user function definitions.

     A pattern can be:
          <STRONG>BEGIN</STRONG>
          <STRONG>END</STRONG>
          expression
          expression , expression

     One, but not both, of <EM>pattern</EM> {<EM>action</EM>} can be omitted.    If
     {<EM>action</EM>}  is omitted it is implicitly { print }.  If <EM>pattern</EM>
     is omitted, then it is implicitly matched.   <STRONG>BEGIN</STRONG>  and  <STRONG>END</STRONG>
     patterns require an action.

     Statements are terminated by newlines, semi-colons or  both.
     Groups  of  statements  such  as  actions or loop bodies are
     blocked via { ... } as in C.  The last statement in a  block
     doesn't  need a terminator.  Blank lines have no meaning; an
     empty statement is terminated with a semi-colon. Long state-
     ments can be continued with a backslash, \.  A statement can
     be broken without a backslash after a comma, left brace, &amp;&amp;,
     ||,  <STRONG>do</STRONG>,  <STRONG>else</STRONG>, the right parenthesis of an <STRONG>if</STRONG>, <STRONG>while</STRONG> or <STRONG>for</STRONG>
     statement, and the right parenthesis of a  function  defini-
     tion.   A comment starts with # and extends to, but does not
     include the end of line.

     The following statements control program flow inside blocks.

          <STRONG>if</STRONG> ( <EM>expr</EM> ) <EM>statement</EM>

          <STRONG>if</STRONG> ( <EM>expr</EM> ) <EM>statement</EM> <STRONG>else</STRONG> <EM>statement</EM>

          <STRONG>while</STRONG> ( <EM>expr</EM> ) <EM>statement</EM>

          <STRONG>do</STRONG> <EM>statement</EM> <STRONG>while</STRONG> ( <EM>expr</EM> )

          <STRONG>for</STRONG> ( <EM>opt</EM>_<EM>expr</EM> ; <EM>opt</EM>_<EM>expr</EM> ; <EM>opt</EM>_<EM>expr</EM> ) <EM>statement</EM>

          <STRONG>for</STRONG> ( <EM>var</EM> <STRONG>in</STRONG> <EM>array</EM> ) <EM>statement</EM>

          <STRONG>continue</STRONG>

          <STRONG>break</STRONG>

  <STRONG>2.</STRONG> <STRONG>Data</STRONG> <STRONG>types,</STRONG> <STRONG>conversion</STRONG> <STRONG>and</STRONG> <STRONG>comparison</STRONG>
     There are two basic data types, numeric and string.  Numeric
     constants  can  be integer like -2, decimal like 1.08, or in
     scientific notation like -1.1e4 or .28E-3.  All numbers  are
     represented  internally  and  all  computations  are done in
     floating point arithmetic.  So for example,  the  expression
     0.2e2 == 20 is true and true is represented as 1.0.

     String constants are enclosed in double quotes.

           "This is a string with a newline at the end.\n"

     Strings can be continued across a line by escaping  (\)  the
     newline.  The following escape sequences are recognized.

          \\        \
          \"        "
          \a        alert, ascii 7
          \b        backspace, ascii 8
          \t        tab, ascii 9
          \n        newline, ascii 10
          \v        vertical tab, ascii 11
          \f        formfeed, ascii 12
          \r        carriage return, ascii 13
          \ddd      1, 2 or 3 octal digits for ascii ddd
          \xhh      1 or 2 hex digits for ascii  hh

     If you escape any other character \c, you get \c, i.e., <STRONG>mawk</STRONG>
     ignores the escape.

     There are really three basic data types; the third is <EM>number</EM>
     <EM>and</EM> <EM>string</EM> which has both a numeric value and a string value
     at  the  same  time.   User  defined  variables  come   into
     existence when first referenced and are initialized to <EM>null</EM>,
     a number and string value which  has  numeric  value  0  and
     string  value  "".  Non-trivial number and string typed data
     come from input and are typically stored  in  fields.   (See
     section 4).

     The type of an expression is determined by its  context  and
     automatic type conversion occurs if needed.  For example, to
     evaluate the statements

          y = x + 2  ;  z = x  "hello"

     The value stored in variable y will be typed numeric.  If  x
     is  not  numeric,  the  value  read  from  x is converted to
     numeric before it is added to 2 and stored in y.  The  value
     stored  in variable z will be typed string, and the value of
     x will be converted to string if necessary and  concatenated
     with "hello".  (Of course, the value and type stored in x is
     not changed by any conversions.)   A  string  expression  is
     converted  to  numeric  using  its longest numeric prefix as
     with <EM>atof</EM>(3).  A numeric expression is converted  to  string
     by  replacing  <EM>expr</EM> with <STRONG>sprintf(CONVFMT</STRONG>, <EM>expr</EM>), unless <EM>expr</EM>
     can be represented on the host machine as an  exact  integer
     then  it  is converted to <STRONG>sprintf</STRONG>("%d", <EM>expr</EM>).  <STRONG>Sprintf()</STRONG> is
     an  AWK  built-in  that  duplicates  the  functionality   of
     <EM>sprintf</EM>(3),  and  <STRONG>CONVFMT</STRONG>  is  a  built-in variable used for
     internal conversion from number to string and initialized to
     "%.6g".  Explicit type conversions can be forced, <EM>expr</EM> "" is
     string and <EM>expr</EM>+0 is numeric.

     To evaluate,  <EM>expr</EM>918  <STRONG>rel-op</STRONG>  <EM>expr</EM>928,  if  both  operands  are
     numeric or number and string then the comparison is numeric;
     if both operands are string the comparison is string; if one
     operand  is  string, the non-string operand is converted and
     the comparison is string.  The result is numeric, 1 or 0.

     In boolean contexts such as, <STRONG>if</STRONG> ( <EM>expr</EM> ) <EM>statement</EM>, a string
     expression evaluates true if and only if it is not the empty
     string ""; numeric values if and  only  if  not  numerically
     zero.

  <STRONG>3.</STRONG> <STRONG>Regular</STRONG> <STRONG>expressions</STRONG>
     In the AWK language, records, fields and strings  are  often
     tested  for  matching a <EM>regular</EM> <EM>expression</EM>.  Regular expres-
     sions are enclosed in slashes, and

          <EM>expr</EM> ~ /<EM>r</EM>/

     is an AWK expression that evaluates to 1 if  <EM>expr</EM>  "matches"
     <EM>r</EM>,  which means a substring of <EM>expr</EM> is in the set of strings
     defined by <EM>r</EM>.  With no match the expression evaluates to  0;
     replacing ~ with the "not match" operator, !~ , reverses the
     meaning.  As  pattern-action pairs,

          /<EM>r</EM>/ { <EM>action</EM> }   and   <STRONG>$0</STRONG> ~ /<EM>r</EM>/ { <EM>action</EM> }

     are the same, and for each  input  record  that  matches  <EM>r</EM>,
     <EM>action</EM>  is executed.  In fact, /<EM>r</EM>/ is an AWK expression that
     is equivalent to (<STRONG>$0</STRONG> ~ /<EM>r</EM>/)  anywhere  except  when  on  the
     right side of a match operator or passed as an argument to a
     built-in function that expects a  regular  expression  argu-
     ment.

     AWK uses extended regular expressions as with <EM>egrep</EM>(1).  The
     regular  expression metacharacters, i.e., those with special
     meaning in regular expressions are

           ^ $ . [ ] | ( ) * + ?

     Regular expressions are built up from characters as follows:

          <EM>c</EM>            matches any non-metacharacter <EM>c</EM>.

          \<EM>c</EM>           matches a character defined  by  the  same
                       escape  sequences used in string constants
                       or the literal character <EM>c</EM> if \<EM>c</EM> is not an
                       escape sequence.

          .            matches any character (including newline).

          ^            matches the front of a string.

          $            matches the back of a string.

          [c918c928c938...]  matches  any  character   in   the   class
                       c918c928c938...  .  An interval of characters is
                       denoted c918-c928 inside a class [...].

          [^c918c928c938...] matches any character  not  in  the  class
                       c918c928c938...

     Regular expressions are built up from other regular  expres-
     sions as follows:

          <EM>r</EM>918<EM>r</EM>928         matches  <EM>r</EM>918  followed  immediately  by  <EM>r</EM>92
8                       (concatenation).

          <EM>r</EM>918 | <EM>r</EM>928      matches <EM>r</EM>918 or <EM>r</EM>928 (alternation).

          <EM>r</EM>*           matches <EM>r</EM> repeated zero or more times.

          <EM>r</EM>+           matches <EM>r</EM> repeated one or more times.

          <EM>r</EM>?           matches <EM>r</EM> zero or once.

          (<EM>r</EM>)          matches <EM>r</EM>, providing grouping.

     The increasing precedence of operators is alternation,  con-
     catenation and unary (*, + or ?).

     For example,

          /^[_a-zA-Z][_a-zA-Z0-9]*$/  and
          /^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

     are matched by AWK identifiers  and  AWK  numeric  constants
     respectively.   Note  that  . has to be escaped to be recog-
     nized as a decimal point, and that  metacharacters  are  not
     special inside character classes.

     Any expression can be used on the right hand side of  the  ~
     or !~ operators or passed to a built-in that expects a regu-
     lar expression.  If needed, it is converted to  string,  and
     then interpreted as a regular expression.  For example,

          BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }

          $0 ~ "^" identifier

     prints all lines that start with an AWK identifier.

     <STRONG>mawk</STRONG> recognizes the  empty  regular  expression,  //,  which
     matches  the empty string and hence is matched by any string
     at the front, back and between every character.   For  exam-
     ple,

          echo  abc | mawk { gsub(//, "X") ; print }
          XaXbXcX


  <STRONG>4.</STRONG> <STRONG>Records</STRONG> <STRONG>and</STRONG> <STRONG>fields</STRONG>
     Records are read in one at a time, and stored in  the  <EM>field</EM>
     variable  <STRONG>$0</STRONG>.   The  record  is  split into <EM>fields</EM> which are
     stored in <STRONG>$1</STRONG>, <STRONG>$2</STRONG>, ..., <STRONG>$NF</STRONG>.  The built-in variable <STRONG>NF</STRONG> is set
     to  the  number of fields, and <STRONG>NR</STRONG> and <STRONG>FNR</STRONG> are incremented by
     1.  Fields above <STRONG>$NF</STRONG> are set to "".

     Assignment to <STRONG>$0</STRONG> causes the fields and <STRONG>NF</STRONG> to be  recomputed.
     Assignment to <STRONG>NF</STRONG> or to a field causes <STRONG>$0</STRONG> to be reconstructed
     by concatenating the <STRONG>$i's</STRONG> separated by <STRONG>OFS</STRONG>.  Assignment to a
     field with index greater than <STRONG>NF</STRONG>, increases <STRONG>NF</STRONG> and causes <STRONG>$0</STRONG>
     to be reconstructed.

     Data input stored in fields is  string,  unless  the  entire
     field  has  numeric  form  and  then  the type is number and
     string.  For example,

          echo 24 24E |
          mawk '{ print($1&gt;100, $1&gt;"100", $2&gt;100, $2&gt;"100") }'
          0 1 1 1

     <STRONG>$0</STRONG> and <STRONG>$2</STRONG> are string and <STRONG>$1</STRONG> is number and string.  The first
     comparison  is  numeric,  the second is string, the third is
     string (100 is converted to "100"), and the last is string.

  <STRONG>5.</STRONG> <STRONG>Expressions</STRONG> <STRONG>and</STRONG> <STRONG>operators</STRONG>
     The expression syntax is similar to C.  Primary  expressions
     are  numeric constants, string constants, variables, fields,
     arrays and function calls. The identifier  for  a  variable,
     array  or  function can be a sequence of letters, digits and
     underscores, that does not start with  a  digit.   Variables
     are  not  declared; they exist when first referenced and are
     initialized to <EM>null</EM>.

     New expressions are composed with the following operators in
     order of increasing precedence.

          <EM>assignment</EM>          =  +=  -=  *=  /=  %=  ^=
          <EM>conditional</EM>         ?  :
          <EM>logical</EM> <EM>or</EM>          ||
          <EM>logical</EM> <EM>and</EM>         &amp;&amp;
          <EM>array</EM> <EM>membership</EM>    <STRONG>in</STRONG>
          <EM>matching</EM>       ~   !~
          <EM>relational</EM>          &lt;  &gt;   &lt;=  &gt;=  ==  !=
          <EM>concatenation</EM>       (no explicit operator)
          <EM>add</EM> <EM>ops</EM>             +  -
          <EM>mul</EM> <EM>ops</EM>             *  /  %
          <EM>unary</EM>               +  -
          <EM>logical</EM> <EM>not</EM>         !
          <EM>exponentiation</EM>      ^
          <EM>inc</EM> <EM>and</EM> <EM>dec</EM>         ++ -- (both post and pre)
          <EM>field</EM>               $

     Assignment, conditional and exponentiation  associate  right
     to  left;  the other operators associate left to right.  Any
     expression can be parenthesized.

  <STRONG>6.</STRONG> <STRONG>Arrays</STRONG>
     Awk provides one-dimensional  arrays.   Array  elements  are
     expressed  as  <EM>array</EM>[<EM>expr</EM>].  <EM>Expr</EM> is internally converted to
     string type, so, for example, A[1] and A["1"] are  the  same
     element  and  the  actual  index  is "1".  Arrays indexed by
     strings are called associative arrays.  Initially  an  array
     is  empty;  elements  exist when first accessed.  An expres-
     sion, <EM>expr</EM> <STRONG>in</STRONG> <EM>array</EM> evaluates to 1  if  <EM>array</EM>[<EM>expr</EM>]  exists,
     else to 0.

     There is a form of the <STRONG>for</STRONG> statement that  loops  over  each
     index of an array.

          <STRONG>for</STRONG> ( <EM>var</EM> <STRONG>in</STRONG> <EM>array</EM> ) <EM>statement</EM>

     sets <EM>var</EM> to each index of <EM>array</EM> and executes <EM>statement</EM>.  The
     order  that  <EM>var</EM>  transverses  the  indices  of <EM>array</EM> is not
     defined.

     The statement, <STRONG>delete</STRONG> <EM>array</EM>[<EM>expr</EM>], causes <EM>array</EM>[<EM>expr</EM>] not to
     exist.   <STRONG>mawk</STRONG>  supports  an  extension,  <STRONG>delete</STRONG> <EM>array</EM>, which
     deletes all elements of <EM>array</EM>.

     Multidimensional arrays are synthesized  with  concatenation
     using  the  built-in variable <STRONG>SUBSEP</STRONG>.  <EM>array</EM>[<EM>expr</EM>918,<EM>expr</EM>928] is
     equivalent to <EM>array</EM>[<EM>expr</EM>918 <STRONG>SUBSEP</STRONG> <EM>expr</EM>928].  Testing for a mul-
     tidimensional element uses a parenthesized index, such as

          if ( (i, j) in A )  print A[i, j]


  <STRONG>7.</STRONG> <STRONG>Builtin-variables</STRONG>
     The following variables are built-in and initialized  before
     program execution.

          <STRONG>ARGC</STRONG>      number of command line arguments.

          <STRONG>ARGV</STRONG>      array of command line arguments, 0..ARGC-1.

          <STRONG>CONVFMT</STRONG>   format for internal conversion of numbers  to
                    string, initially = "%.6g".

          <STRONG>ENVIRON</STRONG>   array indexed by environment  variables.   An
                    environment  string,  <EM>var</EM>=<EM>value</EM>  is stored as
                    <STRONG>ENVIRON</STRONG>[<EM>var</EM>] = <EM>value</EM>.

          <STRONG>FILENAME</STRONG>  name of the current input file.

          <STRONG>FNR</STRONG>       current record number in <STRONG>FILENAME</STRONG>.

          <STRONG>FS</STRONG>        splits  records  into  fields  as  a  regular
                    expression.

          <STRONG>NF</STRONG>        number of fields in the current record.

          <STRONG>NR</STRONG>        current record  number  in  the  total  input
                    stream.

          <STRONG>OFMT</STRONG>      format  for  printing  numbers;  initially  =
                    "%.6g".

          <STRONG>OFS</STRONG>       inserted between fields on output,  initially
                    = " ".

          <STRONG>ORS</STRONG>       terminates each record on output, initially =
                    "\n".

          <STRONG>RLENGTH</STRONG>   length set by the last call to  the  built-in
                    function, <STRONG>match()</STRONG>.

          <STRONG>RS</STRONG>        input record separator, initially = "\n".

          <STRONG>RSTART</STRONG>    index set by the last call to <STRONG>match()</STRONG>.

          <STRONG>SUBSEP</STRONG>    used to build multiple array subscripts, ini-
                    tially = "\034".

  <STRONG>8.</STRONG> <STRONG>Built-in</STRONG> <STRONG>functions</STRONG>
     String functions

          gsub(<EM>r</EM>,<EM>s</EM>,<EM>t</EM>)  gsub(<EM>r</EM>,<EM>s</EM>)
               Global  substitution,  every  match   of   regular
               expression  <EM>r</EM>  in variable <EM>t</EM> is replaced by string
               <EM>s</EM>.  The number of replacements is returned.  If  <EM>t</EM>
               is  omitted,  <STRONG>$0</STRONG> is used.  An &amp; in the replacement
               string <EM>s</EM> is replaced by the matched  substring  of
               <EM>t</EM>.   \&amp; and \\ put  literal &amp; and \, respectively,
               in the replacement string.

          index(<EM>s</EM>,<EM>t</EM>)
               If <EM>t</EM> is a substring of <EM>s</EM>, then the position  where
               <EM>t</EM>  starts  is  returned,  else 0 is returned.  The
               first character of <EM>s</EM> is in position 1.

          length(<EM>s</EM>)
               Returns the length of string <EM>s</EM>.

          match(<EM>s</EM>,<EM>r</EM>)
               Returns the index of the first  longest  match  of
               regular expression <EM>r</EM> in string <EM>s</EM>.  Returns 0 if no
               match.  As a side effect, <STRONG>RSTART</STRONG>  is  set  to  the
               return value.  <STRONG>RLENGTH</STRONG> is set to the length of the
               match or -1 if no match.  If the empty  string  is
               matched, <STRONG>RLENGTH</STRONG> is set to 0, and 1 is returned if
               the match is at  the  front,  and  length(<EM>s</EM>)+1  is
               returned if the match is at the back.

          split(<EM>s</EM>,<EM>A</EM>,<EM>r</EM>)  split(<EM>s</EM>,<EM>A</EM>)
               String <EM>s</EM> is split into fields by  regular  expres-
               sion  <EM>r</EM>  and  the  fields are loaded into array <EM>A</EM>.
               The number of fields is returned.  See section  11
               below  for  more  detail.   If <EM>r</EM> is omitted, <STRONG>FS</STRONG> is
               used.

          sprintf(<EM>format</EM>,<EM>expr</EM>-<EM>list</EM>)
               Returns  a  string  constructed   from   <EM>expr</EM>-<EM>list</EM>
               according  to  <EM>format</EM>.   See  the  description  of
               printf() below.

          sub(<EM>r</EM>,<EM>s</EM>,<EM>t</EM>)  sub(<EM>r</EM>,<EM>s</EM>)
               Single substitution, same as gsub() except at most
               one substitution.

          substr(<EM>s</EM>,<EM>i</EM>,<EM>n</EM>)  substr(<EM>s</EM>,<EM>i</EM>)
               Returns the substring of  string  <EM>s</EM>,  starting  at
               index <EM>i</EM>, of length <EM>n</EM>.  If <EM>n</EM> is omitted, the suffix
               of <EM>s</EM>, starting at <EM>i</EM> is returned.

          tolower(<EM>s</EM>)
               Returns a copy of <EM>s</EM> with all upper case characters
               converted to lower case.

          toupper(<EM>s</EM>)
               Returns a copy of <EM>s</EM> with all lower case characters
               converted to upper case.

     Arithmetic functions

          atan2(<EM>y</EM>,<EM>x</EM>)     Arctan of <EM>y</EM>/<EM>x</EM> between -J and J.

          cos(<EM>x</EM>)         Cosine function, <EM>x</EM> in radians.

          exp(<EM>x</EM>)         Exponential function.

          int(<EM>x</EM>)         Returns <EM>x</EM> truncated towards zero.

          log(<EM>x</EM>)         Natural logarithm.

          rand()         Returns a random number between zero and one.

          sin(<EM>x</EM>)         Sine function, <EM>x</EM> in radians.

          sqrt(<EM>x</EM>)        Returns square root of <EM>x</EM>.

          srand(<EM>expr</EM>)  srand()
               Seeds the random number generator, using the clock
               if  <EM>expr</EM>  is omitted, and returns the value of the
               previous seed.  <STRONG>mawk</STRONG> seeds the random number  gen-
               erator  from  the  clock at startup so there is no
               real need to call srand().  Srand(<EM>expr</EM>) is  useful
               for repeating pseudo random sequences.

  <STRONG>9.</STRONG> <STRONG>Input</STRONG> <STRONG>and</STRONG> <STRONG>output</STRONG>
     There are two output statements, <STRONG>print</STRONG> and <STRONG>printf</STRONG>.

          print
               writes <STRONG>$0</STRONG>  <STRONG>ORS</STRONG> to standard output.

          print <EM>expr</EM>918, <EM>expr</EM>928, ..., <EM>expr</EM>9n

</PRE>
<H2>8               writes expr918 OFS expr928 OFS ... expr9n8 ORS to  stan-</H2><PRE>
               dard output.  Numeric expressions are converted to
               string with <STRONG>OFMT</STRONG>.

          printf <EM>format</EM>, <EM>expr</EM>-<EM>list</EM>
               duplicates the printf C library  function  writing
               to  standard  output.   The complete ANSI C format
               specifications are recognized with conversions %c,
               %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and
               %%, and conversion qualifiers h and l.

     The argument list to  print  or  printf  can  optionally  be
     enclosed  in  parentheses.  Print formats numbers using <STRONG>OFMT</STRONG>
     or "%d" for exact integers.  "%c" with  a  numeric  argument
     prints  the  corresponding  8  bit  character, with a string
     argument it prints the first character of the  string.   The
     output  of  print  and printf can be redirected to a file or
     command by appending &gt; <EM>file</EM>, &gt;&gt; <EM>file</EM> or | <EM>command</EM> to the end
     of  the  print statement.  Redirection opens <EM>file</EM> or <EM>command</EM>
     only once, subsequent redirections  append  to  the  already
     open  stream.   By  convention, <STRONG>mawk</STRONG> associates the filename
     "/dev/stderr" with stderr which allows print and  printf  to
     be  redirected  to  stderr.   <STRONG>mawk</STRONG>  also  associates "-" and
     "/dev/stdout" with  stdin  and  stdout  which  allows  these
     streams to be passed to functions.

     The input function <STRONG>getline</STRONG> has the following variations.

          getline
               reads into <STRONG>$0</STRONG>, updates the fields, <STRONG>NF</STRONG>, <STRONG>NR</STRONG> and <STRONG>FNR</STRONG>.

          getline &lt; <EM>file</EM>
               reads into <STRONG>$0</STRONG> from <EM>file</EM>, updates  the  fields  and
               <STRONG>NF</STRONG>.

          getline <EM>var</EM>
               reads the next record into  <EM>var</EM>,  updates  <STRONG>NR</STRONG>  and
               <STRONG>FNR</STRONG>.

          getline <EM>var</EM> &lt; <EM>file</EM>
               reads the next record of <EM>file</EM> into <EM>var</EM>.

           <EM>command</EM> | getline
               pipes a record from <EM>command</EM> into  <STRONG>$0</STRONG>  and  updates
               the fields and <STRONG>NF</STRONG>.

           <EM>command</EM> | getline <EM>var</EM>
               pipes a record from <EM>command</EM> into <EM>var</EM>.

     Getline returns 0 on end-of-file, -1 on error, otherwise 1.

     Commands on the end of pipes are executed by /bin/sh.

     The function <STRONG>close</STRONG>(<EM>expr</EM>) closes the file or pipe  associated
     with  <EM>expr</EM>.   Close  returns  0 if <EM>expr</EM> is an open file, the
     exit status if <EM>expr</EM> is a piped command,  and  -1  otherwise.
     Close  is  used  to  reread a file or command, make sure the
     other end of an output pipe is  finished  or  conserve  file
     resources.

     The function <STRONG>fflush</STRONG>(<EM>expr</EM>) flushes the output  file  or  pipe
     associated  with  <EM>expr</EM>.  Fflush returns 0 if <EM>expr</EM> is an open
     output stream else -1.  Fflush without an  argument  flushes
     stdout.

     The function <STRONG>system</STRONG>(<EM>expr</EM>) uses /bin/sh to execute  <EM>expr</EM>  and
     returns  the  exit status of the command <EM>expr</EM>.  Changes made
     to the <STRONG>ENVIRON</STRONG> array are not  passed  to  commands  executed
     with <STRONG>system</STRONG> or pipes.

  <STRONG>10.</STRONG> <STRONG>User</STRONG> <STRONG>defined</STRONG> <STRONG>functions</STRONG>
     The syntax for a user defined function is

          <STRONG>function</STRONG> name( <EM>args</EM> ) { <EM>statements</EM> }

     The function body can contain a return statement

          <STRONG>return</STRONG> <EM>opt</EM>_<EM>expr</EM>

     A return statement is not required. Function  calls  may  be
     nested  or  recursive.   Functions are passed expressions by
     value and arrays by reference.   Extra  arguments  serve  as
     local  variables  and are initialized to <EM>null</EM>.  For example,
     csplit(<EM>s</EM>,<EM>A</EM>) puts each  character  of  <EM>s</EM>  into  array  <EM>A</EM>  and
     returns the length of <EM>s</EM>.

          function csplit(s, A,    n, i)
          {
            n = length(s)
            for( i = 1 ; i &lt;= n ; i++ ) A[i] = substr(s, i, 1)
            return n
          }

     Putting extra space between passed arguments and local vari-
     ables  is  conventional.  Functions can be referenced before
     they are defined, but the function name and the '('  of  the
     arguments must touch to avoid confusion with concatenation.

  <STRONG>11.</STRONG> <STRONG>Splitting</STRONG> <STRONG>strings,</STRONG> <STRONG>records</STRONG> <STRONG>and</STRONG> <STRONG>files</STRONG>
     Awk programs use the same algorithm to  split  strings  into
     arrays  with  split(),  and records into fields on <STRONG>FS</STRONG>.  <STRONG>mawk</STRONG>
     uses essentially the same  algorithm  to  split  files  into
     records on <STRONG>RS</STRONG>.

     Split(<EM>expr</EM>,<EM>A</EM>,<EM>sep</EM>) works as follows:

          (1)  If <EM>sep</EM> is omitted, it is replaced by <STRONG>FS</STRONG>.  <EM>Sep</EM>  can
               be  an expression or regular expression.  If it is
               an expression of non-string type, it is  converted
               to string.

          (2)  If <EM>sep</EM> = " " (a single  space),  then  &lt;SPACE&gt;  is
               trimmed  from  the front and back of <EM>expr</EM>, and <EM>sep</EM>
               becomes &lt;SPACE&gt;.  <STRONG>mawk</STRONG> defines &lt;SPACE&gt; as the reg-
               ular   expression  /[ \t\n]+/.  Otherwise  <EM>sep</EM>  is
               treated  as  a  regular  expression,  except  that
               meta-characters are ignored for a string of length
               1, e.g., split(x, A, "*") and  split(x,  A,  /\*/)
               are the same.

          (3)  If <EM>expr</EM> is not string, it is converted to  string.
               If  <EM>expr</EM>  is  then  the  empty  string "", split()
               returns 0 and <EM>A</EM>  is  set  empty.   Otherwise,  all
               non-overlapping,  non-null  and longest matches of
               <EM>sep</EM> in <EM>expr</EM>, separate <EM>expr</EM> into fields  which  are
               loaded  into  <EM>A</EM>.   The  fields are placed in A[1],
               A[2], ..., A[n] and split() returns n, the  number
               of fields which is the number of matches plus one.
               Data placed in  <EM>A</EM>  that  looks  numeric  is  typed
               number and string.

     Splitting records into fields  works  the  same  except  the
     pieces  are loaded into <STRONG>$1</STRONG>, <STRONG>$2</STRONG>,..., <STRONG>$NF</STRONG>.  If <STRONG>$0</STRONG> is empty, <STRONG>NF</STRONG>
     is set to 0 and all <STRONG>$i</STRONG> to "".

     <STRONG>mawk</STRONG> splits files into records by the  same  algorithm,  but
     with  the  slight  difference that <STRONG>RS</STRONG> is really a terminator
     instead of a separator. (<STRONG>ORS</STRONG> is really a terminator too).

          E.g., if <STRONG>FS</STRONG> = ":+" and <STRONG>$0</STRONG> = "a::b:" , then <STRONG>NF</STRONG> =  3  and
          <STRONG>$1</STRONG>  =  "a", <STRONG>$2</STRONG> = "b" and <STRONG>$3</STRONG> = "", but if "a::b:" is the
          contents of an input file and <STRONG>RS</STRONG> = ":+", then there are
          two records "a" and "b".

     <STRONG>RS</STRONG> = " " is not special.

     If <STRONG>FS</STRONG> = "", then <STRONG>mawk</STRONG>  breaks  the  record  into  individual
     characters, and, similarly, split(<EM>s</EM>,<EM>A</EM>,"") places the indivi-
     dual characters of <EM>s</EM> into <EM>A</EM>.

  <STRONG>12.</STRONG> <STRONG>Multi-line</STRONG> <STRONG>records</STRONG>
     Since <STRONG>mawk</STRONG> interprets <STRONG>RS</STRONG> as a regular expression, multi-line
     records  are  easy.  Setting <STRONG>RS</STRONG> = "\n\n+", makes one or more
     blank lines separate records.  If <STRONG>FS</STRONG> = "  "  (the  default),
     then single newlines, by the rules for &lt;SPACE&gt; above, become
     space and single newlines are field separators.

          For example, if a file is "a b\nc\n\n",  <STRONG>RS</STRONG>  =  "\n\n+"
          and  <STRONG>FS</STRONG>  =  " ", then there is one record "a b\nc" with
          three fields "a", "b" and "c".   Changing  <STRONG>FS</STRONG>  =  "\n",
          gives two fields "a b" and "c"; changing <STRONG>FS</STRONG> = "", gives
          one field identical to the record.

     If you want lines with  spaces  or  tabs  to  be  considered
     blank,  set  <STRONG>RS</STRONG>  =  "\n([ \t]*\n)+".  For compatibility with
     other awks, setting <STRONG>RS</STRONG> = "" has the same effect as if  blank
     lines are stripped from the front and back of files and then
     records are determined as if <STRONG>RS</STRONG> = "\n\n+".   Posix  requires
     that  "\n"  always separates records when <STRONG>RS</STRONG> = "" regardless
     of the value of <STRONG>FS</STRONG>.  <STRONG>mawk</STRONG> does not support this  convention,
     because defining "\n" as &lt;SPACE&gt; makes it unnecessary.

     Most of the time when you change <STRONG>RS</STRONG> for multi-line  records,
     you  will  also  want  to change <STRONG>ORS</STRONG> to "\n\n" so the record
     spacing is preserved on output.

  <STRONG>13.</STRONG> <STRONG>Program</STRONG> <STRONG>execution</STRONG>
     This section  describes  the  order  of  program  execution.
     First  <STRONG>ARGC</STRONG> is set to the total number of command line argu-
     ments passed to the execution phase of the program.  <STRONG>ARGV[0]</STRONG>
     is  set  the  name  of  the  AWK interpreter and <STRONG>ARGV[1]</STRONG> ...
     <STRONG>ARGV[ARGC-1]</STRONG> holds  the  remaining  command  line  arguments
     exclusive of options and program source.  For example with

          mawk  -f  prog  v=1  A  t=hello  B

     <STRONG>ARGC</STRONG> = 5 with <STRONG>ARGV[0]</STRONG> = "mawk", <STRONG>ARGV[1]</STRONG> = "v=1",  <STRONG>ARGV[2]</STRONG>  =
     "A", <STRONG>ARGV[3]</STRONG> = "t=hello" and <STRONG>ARGV[4]</STRONG> = "B".

     Next, each <STRONG>BEGIN</STRONG> block is executed in order.  If the program
     consists  entirely  of  <STRONG>BEGIN</STRONG>  blocks,  then  execution ter-
     minates, else an input stream is opened and  execution  con-
     tinues.  If <STRONG>ARGC</STRONG> equals 1, the input stream is set to stdin,
     else  the command line arguments  <STRONG>ARGV[1]</STRONG>  ...  <STRONG>ARGV[ARGC-1]</STRONG>
     are examined for a file argument.

     The command line arguments  divide  into  three  sets:  file
     arguments,  assignment  arguments  and empty strings "".  An
     assignment has the form  <EM>var</EM>=<EM>string</EM>.   When  an  <STRONG>ARGV[i]</STRONG>  is
     examined  as  a possible file argument, if it is empty it is
     skipped; if it is an assignment argument, the assignment  to
     <EM>var</EM>  takes  place  and  <STRONG>i</STRONG>  skips  to the next argument; else
     <STRONG>ARGV[i]</STRONG> is opened for input.  If it fails to open, execution
     terminates with exit code 2.  If no command line argument is
     a file argument, then input comes from stdin.  Getline in  a
     <STRONG>BEGIN</STRONG>  action  opens  input.  "-" as a file argument denotes
     stdin.

     Once an input stream is open, each input  record  is  tested
     against  each  <EM>pattern</EM>,  and  if  it matches, the associated
     <EM>action</EM> is executed.  An expression pattern matches if it  is
     boolean  true  (see  the end of section 2).  A <STRONG>BEGIN</STRONG> pattern
     matches before any input has been read, and an  <STRONG>END</STRONG>  pattern
     matches  after  all  input  has been read.  A range pattern,
     <EM>expr</EM>1,<EM>expr</EM>2 , matches every  record  between  the  match  of
     <EM>expr</EM>1 and the match <EM>expr</EM>2 inclusively.

     When end of file occurs on the input stream,  the  remaining
     command line arguments are examined for a file argument, and
     if there is one it is opened, else the <STRONG>END</STRONG> <EM>pattern</EM>  is  con-
     sidered matched and all <STRONG>END</STRONG> <EM>actions</EM> are executed.

     In the example, the assignment v=1  takes  place  after  the
     <STRONG>BEGIN</STRONG>  <EM>actions</EM>  are  executed,  and  the data placed in v is
     typed number and string.  Input is then read  from  file  A.
     On  end  of file A, t is set to the string "hello", and B is
     opened for input.  On end of file B,  the  <STRONG>END</STRONG>  <EM>actions</EM>  are
     executed.

     Program flow at the <EM>pattern</EM> {<EM>action</EM>} level  can  be  changed
     with the

          <STRONG>next</STRONG>
          <STRONG>exit</STRONG>  <EM>opt</EM>_<EM>expr</EM>

     statements.  A <STRONG>next</STRONG> statement causes the next  input  record
     to  be  read  and  pattern testing to restart with the first
     <EM>pattern</EM> {<EM>action</EM>} pair in the  program.   An  <STRONG>exit</STRONG>  statement
     causes  immediate  execution  of  the <STRONG>END</STRONG> actions or program
     termination if there are none or if the <STRONG>exit</STRONG>  occurs  in  an
     <STRONG>END</STRONG> action.  The <EM>opt</EM>_<EM>expr</EM> sets the exit value of the program
     unless overridden by a later <STRONG>exit</STRONG> or subsequent error.


</PRE>
<H2>EXAMPLES</H2><PRE>
     1. emulate cat.

          { print }

     2. emulate wc.

          { chars += length($0) + 1  # add one for the \n
            words += NF
          }

          END{ print NR, words, chars }

     3. count the number of unique "real words".
          BEGIN { FS = "[^A-Za-z]+" }

          { for(i = 1 ; i &lt;= NF ; i++)  word[$i] = "" }

          END { delete word[""]
                for ( i in word )  cnt++
                print cnt
          }

     4. sum the second field of every record based on  the  first
     field.

          $1 ~ /credit|gain/ { sum += $2 }
          $1 ~ /debit|loss/  { sum -= $2 }

          END { print sum }

     5. sort a file, comparing as string

          { line[NR] = $0 "" }  # make sure of comparison type
                          # in case some lines look numeric

          END {  isort(line, NR)
            for(i = 1 ; i &lt;= NR ; i++) print line[i]
          }

          #insertion sort of A[1..n]
          function isort( A, n,    i, j, hold)
          {
            for( i = 2 ; i &lt;= n ; i++)
            {
              hold = A[j = i]
              while ( A[j-1] &gt; hold )
              { j-- ; A[j+1] = A[j] }
              A[j] = hold
            }
            # sentinel A[0] = "" will be created if needed
          }



</PRE>
<H2>COMPATIBILITY ISSUES</H2><PRE>
     The Posix 1003.2(draft 11.3) definition of the AWK  language
     is  AWK  as  described in the AWK book with a few extensions
     that appeared in SystemVR4 nawk. The extensions are:

          New functions: toupper() and tolower().

          New variables: ENVIRON[] and CONVFMT.

          ANSI  C  conversion  specifications  for  printf()  and
          sprintf().

          New command options:  -v var=value, multiple -f options
          and implementation options as arguments to -W.


     Posix AWK is oriented to operate on files a line at a  time.
     <STRONG>RS</STRONG> can be changed from "\n" to another single character, but
     it is hard to find any use for this - there are no  examples
     in  the AWK book.  By convention, <STRONG>RS</STRONG> = "", makes one or more
     blank lines separate records, allowing  multi-line  records.
     When <STRONG>RS</STRONG> = "", "\n" is always a field separator regardless of
     the value in <STRONG>FS</STRONG>.

     <STRONG>mawk</STRONG>, on the other hand, allows <STRONG>RS</STRONG> to be a  regular  expres-
     sion.  When "\n" appears in records, it is treated as space,
     and <STRONG>FS</STRONG> always determines fields.

     Removing the line at a time paradigm can make some  programs
     simpler  and  can  often  improve performance.  For example,
     redoing example 3 from above,

          BEGIN { RS = "[^A-Za-z]+" }

          { word[ $0 ] = "" }

          END { delete  word[ "" ]
            for( i in word )  cnt++
            print cnt
          }

     counts the number of unique words  by  making  each  word  a
     record.   On  moderate  size  files,  <STRONG>mawk</STRONG> executes twice as
     fast, because of the simplified inner loop.

     The following program replaces  each  comment  by  a  single
     space in a C program file,

          BEGIN {
            RS = "/\*([^*]|\*+[^/*])*\*+/"
               # comment is record separator
            ORS = " "
            getline  hold
            }

            { print hold ; hold = $0 }

            END { printf "%s" , hold }

     Buffering one record is needed to avoid terminating the last
     record with a space.

     With <STRONG>mawk</STRONG>, the following are all equivalent,

          x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

     The strings get scanned twice, once as string  and  once  as
     regular  expression.   On  the string scan, <STRONG>mawk</STRONG> ignores the
     escape on non-escape characters while the AWK book advocates
     \<EM>c</EM> be recognized as <EM>c</EM> which necessitates the double escaping
     of meta-characters in strings. Posix explicitly declines  to
     define  the  behavior  which  passively forces programs that
     must run under a variety of awks to use  the  more  portable
     but less readable, double escape.

     Posix AWK does not recognize "/dev/std{out,err}" or  \x  hex
     escape sequences in strings.  Unlike ANSI C, <STRONG>mawk</STRONG> limits the
     number of digits that follows  \x  to  two  as  the  current
     implementation only supports 8 bit characters.  The built-in
     <STRONG>fflush</STRONG> first appeared in a recent (1993) AT&amp;T  awk  released
     to netlib, and is not part of the posix standard.  Aggregate
     deletion with <STRONG>delete</STRONG> <EM>array</EM> is not part of  the  posix  stan-
     dard.

     Posix explicitly leaves the behavior of <STRONG>FS</STRONG> =  ""  undefined,
     and  mentions splitting the record into characters as a pos-
     sible interpretation, but currently this use is not portable
     across implementations.

     Finally, here is how <STRONG>mawk</STRONG> handles exceptional cases not dis-
     cussed  in the AWK book or the Posix draft.  It is unsafe to
     assume consistency across awks and safe to skip to the  next
     section.

          substr(s, i, n) returns the  characters  of  s  in  the
          intersection  of the closed interval [1, length(s)] and
          the half-open interval [i, i+n).  When  this  intersec-
          tion  is  empty,  the  empty  string  is  returned;  so
          substr("ABC", 1, 0) = "" and  substr("ABC",  -4,  6)  =
          "A".

          Every string, including the empty string,  matches  the
          empty  string  at  the front so, s ~ // and s ~ "", are
          always 1 as is match(s, //) and match(s, "").  The last
          two set <STRONG>RLENGTH</STRONG> to 0.

          index(s, t) is always the same as match(s, t1) where t1
          is  the  same  as t with metacharacters escaped.  Hence
          consistency  with  match  requires  that  index(s,  "")
          always  returns 1.  Also the condition, index(s,t) != 0
          if  and  only  t  is  a  substring   of   s,   requires
          index("","") = 1.

          If getline encounters end of file, getline var,  leaves
          var unchanged.  Similarly, on entry to the <STRONG>END</STRONG> actions,
          <STRONG>$0</STRONG>, the fields and <STRONG>NF</STRONG> have their value  unaltered  from
          the last record.


</PRE>
<H2>SEE ALSO</H2><PRE>
     <EM>egrep</EM>(1)

     Aho, Kernighan and Weinberger, <EM>The</EM> <EM>AWK</EM> <EM>Programming</EM> <EM>Language</EM>,
     Addison-Wesley Publishing, 1988, (the AWK book), defines the
     language, opening with a  tutorial  and  advancing  to  many
     interesting  programs  that  delve  into  issues of software
     design and analysis relevant to programming in any language.

     <EM>The</EM> <EM>GAWK</EM> <EM>Manual</EM>, The Free Software Foundation,  1991,  is  a
     tutorial  and  language  reference that does not attempt the
     depth of the AWK book and assumes the reader may be a novice
     programmer. The section on AWK arrays is excellent.  It also
     discusses Posix requirements for AWK.


</PRE>
<H2>BUGS</H2><PRE>
     <STRONG>mawk</STRONG> cannot handle ascii NUL \0 in the source or data files.
     You can output NUL using printf with %c, and any other 8 bit
     character is acceptable input.

     <STRONG>mawk</STRONG> implements printf() and sprintf() using the  C  library
     functions,  printf  and  sprintf, so full ANSI compatibility
     requires an ANSI C library.  In practice this  means  the  h
     conversion qualifier may not be available.  Also <STRONG>mawk</STRONG> inher-
     its any bugs or limitations of the library functions.

     Implementors of the AWK language  have  shown  a  consistent
     lack of imagination when naming their programs.


</PRE>
<H2>AUTHOR</H2><PRE>
     Mike Brennan (brennan@boeing.com).



















</PRE>
</BODY>
</HTML>
